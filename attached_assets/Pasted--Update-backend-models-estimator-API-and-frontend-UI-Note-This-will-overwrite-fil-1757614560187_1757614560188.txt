# ===== Update backend models, estimator, API, and frontend UI =====
# Note: This will overwrite files. Back up if needed.

# ---------- backend/models.py ----------
cat > backend/models.py <<'EOF'
from typing import Optional
from sqlmodel import SQLModel, Field
from datetime import datetime

class Lead(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    name: Optional[str] = None
    email: str
    phone: Optional[str] = None
    sms_consent: bool = False
    city: Optional[str] = None

    # tracking
    utm_source: Optional[str] = None
    utm_medium: Optional[str] = None
    utm_campaign: Optional[str] = None
    landing_url: Optional[str] = None
    consent_ts: datetime = Field(default_factory=datetime.utcnow)
    client_ip: Optional[str] = None

    created_at: datetime = Field(default_factory=datetime.utcnow)

class Vessel(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    lead_id: int
    brand: str
    model: Optional[str] = None
    year: Optional[int] = None
    engine_type: Optional[str] = None   # shaft | ips | outboard | other
    hours: Optional[int] = None
    gyro: bool = False
    refit_year: Optional[int] = None
    condition: Optional[str] = "average"  # project | fair | average | good | excellent
    estimate_json: Optional[str] = None
    created_at: datetime = Field(default_factory=datetime.utcnow)

class EstimateRequest(SQLModel):
    brand: str
    model: Optional[str] = None
    year: Optional[int] = None
    engine_type: Optional[str] = None
    hours: Optional[int] = None
    gyro: bool = False
    refit_year: Optional[int] = None
    condition: Optional[str] = "average"

class EstimateResponse(SQLModel):
    low: int
    most_likely: int
    high: int
    wholesale: int
    confidence: str
    comps: list
    narrative: str
    used_real_comps: bool
EOF

# ---------- backend/estimate.py ----------
cat > backend/estimate.py <<'EOF'
import os, math, json, datetime
from .models import EstimateRequest, EstimateResponse
from openai import OpenAI

client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

# Brand tiers: rough multipliers that lift/suppress baseline
BRAND_TIER = {
    "sunseeker": 1.25, "princess": 1.22, "azimut": 1.18, "ferretti": 1.20, "pershing": 1.3,
    "viking": 1.28, "hatteras": 1.15, "sea ray": 0.9, "galeon": 1.05, "custom": 1.0
}

# Propulsion class medians — these are not a single fixed baseline;
# we use them as CLASSES, then scale by year/brand/condition.
PROP_CLASS_MEDIAN = {
    "outboard": 180_000,
    "shaft":    800_000,
    "ips":      900_000,
    "other":    350_000,
    None:       450_000,  # fallback if unknown
}

# Condition multipliers
COND_MULT = {
    "project": 0.75,
    "fair": 0.90,
    "average": 1.00,
    "good": 1.07,
    "excellent": 1.12
}

def year_depreciation_factor(year: int | None) -> float:
    """
    A dynamic year factor (no single baseline).
    Recent boats carry higher value; older boats floor at ~0.25 of class median.
    """
    if not year:
        return 1.0
    curr = datetime.date.today().year
    age = max(0, curr - int(year))
    # 6%/yr decay with floor
    factor = max(0.25, (1 - 0.06 * age))
    return round(factor, 3)

def brand_tier_factor(brand: str | None) -> float:
    if not brand:
        return 1.0
    key = brand.strip().lower()
    for b,m in BRAND_TIER.items():
        if b in key:
            return m
    return 1.0

def condition_factor(condition: str | None) -> float:
    return COND_MULT.get((condition or "average").lower(), 1.0)

def propulsion_median(engine_type: str | None) -> int:
    et = (engine_type or "").strip().lower()
    return PROP_CLASS_MEDIAN.get(et if et in PROP_CLASS_MEDIAN else None, PROP_CLASS_MEDIAN[None])

def hours_adjustment(hours: int | None) -> int:
    """
    Reduce value for higher hours; neutral under ~600. Caps at ~-50% of class baseline contribution.
    """
    if hours is None:
        return 0
    over = max(0, int(hours) - 600)
    # ~ $6k per 100h, but we’ll scale again by class later
    return int((over / 100.0) * 6000)

def rules_based_estimate(req: EstimateRequest):
    # Dynamic baseline (no single fixed number):
    # class_median * year_factor * brand_tier * condition
    base_class = propulsion_median(req.engine_type)
    yf = year_depreciation_factor(req.year)
    bf = brand_tier_factor(req.brand)
    cf = condition_factor(req.condition)

    dynamic = base_class * yf * bf * cf

    # Hour penalty is scaled; larger boats tolerate higher hour cost
    hour_penalty = hours_adjustment(req.hours)
    # scale penalty ~25% for outboards, 100% for shafts/IPS
    scale = 0.25 if (req.engine_type or "").lower() == "outboard" else 1.0
    dynamic = max(15_000, int(dynamic - hour_penalty * scale))

    # Gyro premium
    if req.gyro:
        dynamic = int(dynamic * 1.05)

    # Refit premium if occurred 3+ years after build
    if req.refit_year and req.year and (int(req.refit_year) - int(req.year)) >= 3:
        dynamic = int(dynamic * 1.03)

    # Output band
    low, most, high = int(dynamic * 0.92), int(dynamic), int(dynamic * 1.08)
    wholesale = int(most * 0.84)

    # Try real comps first
    comps, used_real = get_real_comps(req), False
    if comps:
        used_real = True
    else:
        comps = [
            {"title":"Comparable A (placeholder)", "ask": most + 100_000, "year": (req.year or 2019), "loa": 68, "region":"FL"},
            {"title":"Comparable B (placeholder)", "ask": most -  50_000, "year": (req.year or 2018), "loa": 66, "region":"FL"},
            {"title":"Comparable C (placeholder)", "ask": most + 180_000, "year": (req.year or 2020), "loa": 65, "region":"FL"},
        ]

    # Confidence: more inputs -> higher confidence
    score = sum([bool(req.year), bool(req.hours), bool(req.brand), bool(req.engine_type), bool(req.condition)])
    confidence = "Low" if score <= 2 else ("Medium" if score <= 4 else "High")

    return low, most, high, wholesale, confidence, comps, used_real

def get_real_comps(req: EstimateRequest):
    """
    Stub for real comparable sales/listings.
    Integrate your authorized feed or DB here and return list of:
    [{"title": str, "ask": int, "year": int, "loa": int|None, "region": str|None, "url": str|None}, ...]
    Filter by brand/model/year±2, propulsion type, and condition when available.
    Return [] if none found.
    """
    # TODO: connect to YATCO/partner API or your comps DB; e.g.:
    # rows = db.fetch_comps(brand=req.brand, model=req.model, year=req.year, engine=req.engine_type)
    # return [{"title": r.title, "ask": r.ask, "year": r.year, "loa": r.loa, "region": r.region, "url": r.url} for]()
