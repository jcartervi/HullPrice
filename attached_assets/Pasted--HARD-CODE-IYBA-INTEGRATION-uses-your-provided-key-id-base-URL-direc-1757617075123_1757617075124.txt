# =========================
# HARD-CODE IYBA INTEGRATION
# (uses your provided key/id/base URL directly in code)
# =========================

# --- backend/iyba_api.py (hard-coded credentials) ---
cat > backend/iyba_api.py <<'EOF'
import time, requests
from typing import List, Dict, Any, Optional

# === YOUR IYBA CREDENTIALS (hard-coded as requested) ===
IYBA_KEY = "9d5aa567b7b54f0619611cf3b2415b4661ecfc94"
IYBA_BROKER_ID = "83692"
BASE = "https://api.yachtbroker.org".rstrip("/")

# Basic cache to reduce API load (per filter)
_CACHE: dict[str, tuple[float, list]] = {}
_TTL = 180  # seconds

def _cache_get(k: str):
    v = _CACHE.get(k)
    if not v: return None
    ts, data = v
    if time.time() - ts > _TTL: return None
    return data

def _cache_put(k: str, data: list):
    _CACHE[k] = (time.time(), data)

def _qs(params: dict) -> dict:
    # Base params for Full Specs JSON API
    p = {
        "key": IYBA_KEY,
        "id": IYBA_BROKER_ID,
        "gallery": "true",
        "engines": "true",
        "generators": "true",
        "textblocks": "true",
        "media": "true",
        "status": "On,Under Contract"
    }
    p.update({k: v for k, v in params.items() if v is not None})
    return p

def _normalize_item(it: Dict[str, Any]) -> Dict[str, Any]:
    year = it.get("year") or it.get("vessel_year")
    brand = it.get("brand") or it.get("make")
    model = it.get("model")
    price = it.get("price") or it.get("ask") or it.get("list_price") or 0
    loa = it.get("length_ft") or it.get("loa") or it.get("length")  # feet
    region = it.get("location") or it.get("region") or it.get("state") or it.get("country")
    url = it.get("url") or it.get("detail_url") or it.get("permalink")
    title = f"{year or ''} {brand or ''} {model or ''}".strip()

    return {
        "title": title,
        "ask": int(price) if price else 0,
        "year": int(year) if year else None,
        "loa": int(loa) if isinstance(loa, (int, float)) else None,
        "region": region,
        "url": url,
        "brand": (brand or "").strip(),
        "model": (model or "").strip(),
        "engine_type": (it.get("propulsion") or it.get("drive_type") or "").strip().lower()
    }

def fetch_full_specs(params: dict) -> List[Dict[str, Any]]:
    """Calls Full Specs JSON API: /listings with your key + broker id."""
    url = f"{BASE}/listings"
    q = _qs(params)
    ck = url + "|" + "&".join(f"{k}={q[k]}" for k in sorted(q))
    cached = _cache_get(ck)
    if cached is not None:
        return cached

    try:
        r = requests.get(url, params=q, timeout=15)
        r.raise_for_status()
        data = r.json()
        items = data.get("results") or data.get("data") or (data if isinstance(data, list) else [])
        norm = [_normalize_item(it) for it in items if isinstance(it, dict)]
        norm = [n for n in norm if n.get("ask") and n.get("year")]
        _cache_put(ck, norm)
        return norm
    except Exception as e:
        print("IYBA fetch error:", e)
        return []

def search_comps(brand: Optional[str], model: Optional[str], year: Optional[int], engine_type: Optional[str], limit: int = 8) -> List[Dict[str, Any]]:
    """Fetch a broad set then filter client-side."""
    raw = fetch_full_specs({})
    if not raw:
        return []

    def match(it):
        if brand and brand.lower() not in (it.get("brand","").lower()):
            return False
        if model and model.lower() not in (it.get("model","").lower()):
            return False
        if year and it.get("year") and abs(int(it["year"]) - int(year)) > 3:
            return False
        if engine_type:
            et = it.get("engine_type","")
            wanted = engine_type.lower()
            if wanted not in et:
                if not (wanted=="shaft" and "shaft" in et) and not (wanted=="ips" and "ips" in et) and not (wanted=="outboard" and "outboard" in et):
                    return False
        return True

    filt = [it for it in raw if match(it)]
    if year:
        filt.sort(key=lambda x: (abs((x.get("year") or year) - year), abs((x.get("ask") or 0))))
    return filt[:limit]
EOF

# --- Patch backend/estimate.py to import and use search_comps ---
python - <<'PY'
import re, pathlib
p = pathlib.Path("backend/estimate.py")
s = p.read_text()
if "from .iyba_api import search_comps" not in s:
    s = s.replace("from openai import OpenAI", "from openai import OpenAI\nfrom .iyba_api import search_comps")
if "def get_real_comps(" in s:
    s = re.sub(r"def get_real_comps\(req: EstimateRequest\):[\s\S]*?return \[\]",
               "def get_real_comps(req: EstimateRequest):\n"
               "    try:\n"
               "        comps = search_comps(req.brand, req.model, req.year, req.engine_type, limit=8)\n"
               "        return comps or []\n"
               "    except Exception as e:\n"
               "        print('get_real_comps error:', e)\n"
               "        return []",
               s)
else:
    s += ("\n\ndef get_real_comps(req: EstimateRequest):\n"
          "    try:\n"
          "        comps = search_comps(req.brand, req.model, req.year, req.engine_type, limit=8)\n"
          "        return comps or []\n"
          "    except Exception as e:\n"
          "        print('get_real_comps error:', e)\n"
          "        return []\n")
p.write_text(s)
print("estimate.py wired to IYBA hard-coded client.")
PY

# --- Add a quick smoke test route if not present ---
python - <<'PY'
import pathlib
p = pathlib.Path("backend/main.py")
s = p.read_text()
if "/api/iyba-smoke" not in s:
    s = s.replace("return {\"ok\": True, \"estimate\": est.dict()}", "return {\"ok\": True, \"estimate\": est.dict()}\n\n@app.get('/api/iyba-smoke')\ndef iyba_smoke():\n    from .iyba_api import search_comps\n    data = search_comps('Sunseeker', None, 2019, 'shaft', limit=5)\n    return {\"count\": len(data), \"sample\": data[:3]}")
    p.write_text(s)
    print("Added /api/iyba-smoke route.")
else:
    print("Smoke route already exists.")
PY

echo "IYBA hard-coded integration complete."
