# ===============================
# FUEL TYPE SWAP (Engine -> Fuel)
# ===============================

# --- backend/models.py ---
cat > backend/models.py <<'EOF'
from typing import Optional
from sqlmodel import SQLModel, Field
from datetime import datetime

class Lead(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    name: Optional[str] = None
    email: str
    phone: Optional[str] = None
    sms_consent: bool = False
    city: Optional[str] = None

    # tracking
    utm_source: Optional[str] = None
    utm_medium: Optional[str] = None
    utm_campaign: Optional[str] = None
    landing_url: Optional[str] = None
    consent_ts: datetime = Field(default_factory=datetime.utcnow)
    client_ip: Optional[str] = None

    created_at: datetime = Field(default_factory=datetime.utcnow)

class Vessel(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    lead_id: int
    brand: str
    model: Optional[str] = None
    year: Optional[int] = None
    fuel_type: Optional[str] = None     # "gas" | "diesel" | "unknown"
    hours: Optional[int] = None
    gyro: bool = False
    refit_year: Optional[int] = None
    condition: Optional[str] = "average"  # project | fair | average | good | excellent
    estimate_json: Optional[str] = None
    created_at: datetime = Field(default_factory=datetime.utcnow)

class EstimateRequest(SQLModel):
    brand: str
    model: Optional[str] = None
    year: Optional[int] = None
    fuel_type: Optional[str] = None      # "gas" | "diesel" | "unknown"
    hours: Optional[int] = None
    gyro: bool = False
    refit_year: Optional[int] = None
    condition: Optional[str] = "average"

class EstimateResponse(SQLModel):
    low: int
    most_likely: int
    high: int
    wholesale: int
    confidence: str
    comps: list
    narrative: str
    used_real_comps: bool
EOF

# --- backend/estimate.py ---
cat > backend/estimate.py <<'EOF'
import os, math, json, datetime
from .models import EstimateRequest, EstimateResponse
from openai import OpenAI
from .iyba_api import search_comps  # real comps

client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

# Brand tiers (relative uplift)
BRAND_TIER = {
    "sunseeker": 1.25, "princess": 1.22, "azimut": 1.18, "ferretti": 1.20, "pershing": 1.30,
    "viking": 1.28, "hatteras": 1.15, "sea ray": 0.92, "galeon": 1.05, "custom": 1.00
}

# Fuel class medians (broad signal, not a fixed baseline)
FUEL_MEDIAN = {
    "gas":     220_000,   # typical outboards / smaller cruisers
    "diesel":  900_000,   # sportfish / motor yachts
    "unknown": 450_000,
    None:      450_000,
}

COND_MULT = {"project":0.75,"fair":0.90,"average":1.00,"good":1.07,"excellent":1.12}

def year_depreciation_factor(year: int | None) -> float:
    if not year:
        return 1.0
    curr = datetime.date.today().year
    age = max(0, curr - int(year))
    return max(0.25, round(1 - 0.06*age, 3))  # floor at 0.25

def brand_tier_factor(brand: str | None) -> float:
    if not brand: return 1.0
    k = brand.strip().lower()
    for b,m in BRAND_TIER.items():
        if b in k: return m
    return 1.0

def condition_factor(condition: str | None) -> float:
    return COND_MULT.get((condition or "average").lower(), 1.0)

def fuel_median(fuel_type: str | None) -> int:
    ft = (fuel_type or "unknown").strip().lower()
    return FUEL_MEDIAN.get(ft, FUEL_MEDIAN["unknown"])

def hours_adjustment(hours: int | None, fuel_type: str | None) -> int:
    if hours is None: return 0
    over = max(0, int(hours) - 600)
    # Gas boats often accept higher RPM cycles; slightly lower penalty
    base_per_100 = 6000 if (fuel_type or "").lower() == "diesel" else 4500
    return int((over / 100.0) * base_per_100)

def rules_based_estimate(req: EstimateRequest):
    base_class = fuel_median(req.fuel_type)
    yf = year_depreciation_factor(req.year)
    bf = brand_tier_factor(req.brand)
    cf = condition_factor(req.condition)

    dynamic = base_class * yf * bf * cf
    dynamic = max(15_000, int(dynamic - hours_adjustment(req.hours, req.fuel_type)))

    if req.gyro: dynamic = int(dynamic * 1.05)
    if req.refit_year and req.year and (int(req.refit_year) - int(req.year)) >= 3:
        dynamic = int(dynamic * 1.03)

    low, most, high = int(dynamic*0.92), int(dynamic), int(dynamic*1.08)
    wholesale = int(most * 0.84)

    comps = get_real_comps(req)
    used_real = bool(comps)
    if not comps:
        comps = [
            {"title":"Comparable A (placeholder)", "ask": most + 100_000, "year": (req.year or 2019), "loa": 68, "region":"FL"},
            {"title":"Comparable B (placeholder)", "ask": most -  50_000, "year": (req.year or 2018), "loa": 66, "region":"FL"},
            {"title":"Comparable C (placeholder)", "ask": most + 180_000, "year": (req.year or 2020), "loa": 65, "region":"FL"},
        ]

    score = sum([bool(req.year), bool(req.hours), bool(req.brand), bool(req.fuel_type), bool(req.condition)])
    confidence = "Low" if score <= 2 else ("Medium" if score <= 4 else "High")

    return low, most, high, wholesale, confidence, comps, used_real

def get_real_comps(req: EstimateRequest):
    try:
        return search_comps(req.brand, req.model, req.year, req.fuel_type, limit=8) or []
    except Exception as e:
        print("get_real_comps error:", e)
        return []

def narrative_for_estimate(req: EstimateRequest, low, most, high, used_real):
    cond = (req.condition or "average").capitalize()
    ftxt = (req.fuel_type or "unknown").capitalize()
    prompt = f"""
    You are a yacht valuation assistant. In 4-6 concise sentences, explain why the price range
    ${low:,} - ${high:,} (USD) is reasonable for a {req.year or ''} {req.brand} {req.model or ''},
    using fuel type '{ftxt}', ~{req.hours or 'unknown'} engine hours, and condition '{cond}'.
    Mention gyro/refit if present. Indicate whether real comparables were used: {'yes' if used_real else 'no'}.
    Avoid legal disclaimers and regional commentary.
    """
    try:
        resp = client.responses.create(model="gpt-5.1-mini", input=prompt)
        return resp.output_text
    except Exception:
        return ("This estimate reflects brand, year, fuel type, hours, condition, gyro, and refit inputs. "
                f"Comparable data used: {'yes' if used_real else 'no'}.")

def estimate(req: EstimateRequest) -> EstimateResponse:
    low, most, high, wholesale, confidence, comps, used_real = rules_based_estimate(req)
    narrative = narrative_for_estimate(req, low, most, high, used_real)
    return EstimateResponse(
        low=low, most_likely=most, high=high, wholesale=wholesale,
        confidence=confidence, comps=comps, narrative=narrative, used_real_comps=used_real
    )
EOF

# --- backend/iyba_api.py (add fuel support in normalization & filter) ---
python - <<'PY'
import pathlib, re, json
p = pathlib.Path('backend/iyba_api.py')
s = p.read_text()

# Ensure normalization exposes 'fuel_type'
if "'fuel_type':" not in s:
    s = s.replace(
        '"engine_type": (it.get("propulsion") or it.get("drive_type") or "").strip().lower()',
        '"engine_type": (it.get("propulsion") or it.get("drive_type") or "").strip().lower(),\n'
        '        "fuel_type": (it.get("fuel") or it.get("fuel_type") or "").strip().lower()'
    )

# Update search_comps signature to treat 4th param as fuel_type
s = re.sub(r"def search_comps\(brand: Optional\[str\], model: Optional\[str\], year: Optional\[int\], engine_type: Optional\[str\], limit: int = 8\)",
           "def search_comps(brand: Optional[str], model: Optional[str], year: Optional[int], fuel_type: Optional[str], limit: int = 8)", s)

# Update filter to use fuel_type (fallback heuristics if fuel missing)
s = re.sub(r"if engine_type:\n\s+et = it.get\(\"engine_type\",\"\"\)\n\s+wanted = engine_type.lower\(\)\n\s+if wanted not in et:\n\s+    if not \(wanted==\"shaft\".*?\n\s+        return False",
           "if fuel_type:\n        ft = (it.get('fuel_type','') or '').lower()\n        wanted = fuel_type.lower()\n        if ft:\n            if wanted not in ft:\n                return False\n        else:\n            # Heuristic fallback: if unknown fuel, infer by engine type keywords\n            et = (it.get('engine_type','') or '').lower()\n            if wanted == 'diesel' and ('outboard' in et):\n                return False\n            if wanted == 'gas' and ('shaft' in et or 'ips' in et):\n                return False", s, flags=re.S)

p.write_text(s)
print("iyba_api.py updated for fuel filtering.")
PY

# --- backend/main.py (swap form fields) ---
python - <<'PY'
import pathlib, re
p = pathlib.Path('backend/main.py')
s = p.read_text()

# Replace form param engine_type -> fuel_type
s = s.replace("engine_type: str = Form(None),", "fuel_type: str = Form(None),")
s = s.replace("engine_type=engine_type", "fuel_type=fuel_type")
s = s.replace("engine_type", "fuel_type")  # safe here because we changed models too

p.write_text(s)
print("main.py updated for fuel_type.")
PY

# --- frontend/src/App.jsx (UI: Fuel Type select) ---
cat > frontend/src/App.jsx <<'EOF'
import React, { useEffect, useState } from 'react'
import { submitLead } from './api'

const isEmail = (v) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v || '')
const isPhone = (v) => (v || '').replace(/\D/g,'').length >= 10
const isYear = (v) => !v || (+v >= 1980 && +v <= new Date().getFullYear()+1)
const isHours = (v) => !v || (+v >= 0 && +v <= 10000)

export default function App() {
  const [step, setStep] = useState(1)
  const [loading, setLoading] = useState(false)
  const [estimate, setEstimate] = useState(null)
  const [utm, setUtm] = useState({src:'',med:'',cmp:'',url:''})
  const [errors, setErrors] = useState({})

  const [contact, setContact] = useState({ name:'', email:'', phone:'', sms_consent:true, city:'' })
  const [vessel, setVessel] = useState({
    brand:'', model:'', year:'', fuel_type:'', hours:'', refit_year:'', gyro:false, condition:'average'
  })

  useEffect(()=>{
    const p = new URLSearchParams(window.location.search)
    setUtm({
      src: p.get('utm_source') || '',
      med: p.get('utm_medium') || '',
      cmp: p.get('utm_campaign') || '',
      url: window.location.href
    })
    const saved = localStorage.getItem('valuationForm')
    if (saved) {
      try {
        const { contact: c, vessel: v } = JSON.parse(saved)
        if (c) setContact(prev => ({...prev, ...c}))
        if (v) setVessel(prev => ({...prev, ...v}))
      } catch {}
    }
  },[])

  useEffect(()=>{
    localStorage.setItem('valuationForm', JSON.stringify({contact, vessel}))
  }, [contact, vessel])

  const canContinue1 = isEmail(contact.email) && isPhone(contact.phone)
  const canSubmit2 = vessel.brand && isYear(vessel.year) && isHours(vessel.hours)

  const onSubmit = async () => {
    const e = {}
    if (!canSubmit2) {
      if (!vessel.brand) e.brand = 'Brand is required'
      if (!isYear(vessel.year)) e.year = 'Year looks invalid'
      if (!isHours(vessel.hours)) e.hours = 'Hours look invalid'
      setErrors(e); return
    }
    setErrors({})
    setLoading(true)
    try {
      const form = new FormData()
      Object.entries(contact).forEach(([k,v]) => form.append(k, v))
      Object.entries(vessel).forEach(([k,v]) => form.append(k, v))
      form.append('utm_source', utm.src)
      form.append('utm_medium', utm.med)
      form.append('utm_campaign', utm.cmp)
      form.append('landing_url', utm.url)
      const data = await submitLead(form)
      setEstimate(data.estimate)
      setStep(3)
    } catch (e) { alert(e.message) }
    finally { setLoading(false) }
  }

  return (
    <div className="container">
      <div className="progress">Step {step} of 3</div>
      <h1>What’s your yacht worth today?</h1>
      <p>Instant AI estimate + recent comps. Free. Private.</p>

      {step===1 && (
        <div className="card">
          <h3>Step 1 — Contact</h3>
          <input placeholder="Name (optional)" value={contact.name}
                 onChange={e=>setContact({...contact,name:e.target.value})}/>
          <input placeholder="Email *" value={contact.email}
                 onChange={e=>setContact({...contact,email:e.t
